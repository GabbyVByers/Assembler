	LDI r0 #119
	STR r0 &up
	LDI r0 #115
	STR r0 &down
	LDI r0 #97
	STR r0 &left
	LDI r0 #100
	STR r0 &right

	LDI r0 #127
	STR r0 &head_x
	LDI r0 #127
	STR r0 &head_y

	LDI r0 #119
	STR r0 &currentDirection

	LDI r0 #10
	STR r0 &appleEatenCooldown

	LDI r0 #0
	STR r0 &index

// start loop initApples
label LOOP_START_initApples
	// std::rand() & 255 -> apples_x[index];
	JSR .FUNCTION_std::rand
	LDI r1 #255
	AND r0 r1
	LDI r2 &apples_x
	LDR r3 &index
	ADD r2 r3
	STX r0 r2
	// std::rand() & 255 -> apples_y[index];
	JSR .FUNCTION_std::rand
	LDI r1 #255
	AND r0 r1
	LDI r2 &apples_y
	LDR r3 &index
	ADD r2 r3
	STX r0 r2
	// index + 1 -> index;
	LDR r0 &index
	ADI r0 #1
	STR r0 &index
	// (index >= 16)
	LDR r0 &index
	LDI r1 #16
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 !FLAG_LESS_THAN
	// if () { break initApples; }
	CMP r0 r0
	JMP .END_IF_0 FLAG_ZERO
	JMP .LOOP_END_initApples
label END_IF_0
	// end loop initApples
	JMP .LOOP_START_initApples
label LOOP_END_initApples
	

// start loop main
label LOOP_START_main
	// std::getInput() -> key;
	JSR .FUNCTION_std::getInput
	STR r0 &key
	// (key != 0)
	LDR r0 &key
	LDI r1 #0
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 !FLAG_EQUAL
	// if () { key -> currentDirection; }
	CMP r0 r0
	JMP .END_IF_1 FLAG_ZERO
	LDR r0 &key
	STR r0 &currentDirection
label END_IF_1
	// moveSnakeHead();
	// drawSnakeHead();
	JSR .FUNCTION_moveSnakeHead
	JSR .FUNCTION_drawSnakeHead
	// head_index + 1 -> head_index;
	LDR r0 &head_index
	ADI r0 #1
	STR r0 &head_index
	// head_x -> snake_body_x[head_index];
	LDR r0 &head_x
	LDI r2 &snake_body_x
	LDR r3 &head_index
	ADD r2 r3
	STX r0 r2
	// head_y -> snake_body_y[head_index];
	LDR r0 &head_y
	LDI r2 &snake_body_y
	LDR r3 &head_index
	ADD r2 r3
	STX r0 r2

	// 0 -> index;
	LDI r0 #0
	STR r0 &index
label LOOP_START_eatApple
	// apples_x[index] == head_x
	LDI r2 &apples_x
	LDR r3 &index
	ADD r2 r3
	LDX r0 r2
	LDR r1 &head_x
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_EQUAL
	// if () {} outer
	CMP r0 r0
	JMP .END_IF_2 FLAG_ZERO
	// apples_y[index] == head_y
	LDI r2 &apples_y
	LDR r3 &index
	ADD r2 r3
	LDX r0 r2
	LDR r1 &head_y
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_EQUAL
	// if () {} inner
	CMP r0 r0
	JMP .END_IF_3 FLAG_ZERO
	// appleEatenCooldown + 10 -> appleEatenCooldown;
	LDR r0 &appleEatenCooldown
	ADI r0 #10
	STR r0 &appleEatenCooldown
	// std::rand() & 255 -> apples_x[index];
	JSR .FUNCTION_std::rand
	LDI r1 #255
	AND r0 r1
	LDI r2 &apples_x
	LDR r3 &index
	ADD r2 r3
	STX r0 r2
	// std::rand() & 255 -> apples_y[index];
	JSR .FUNCTION_std::rand
	LDI r1 #255
	AND r0 r1
	LDI r2 &apples_y
	LDR r3 &index
	ADD r2 r3
	STX r0 r2
	// break eatApple
	JMP .LOOP_END_eatApple
label END_IF_3
label END_IF_2

	// index + 1 -> index;
	LDR r0 &index
	ADI r0 #1
	STR r0 &index
	// index >= 16
	LDR r0 &index
	LDI r1 #16
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 !FLAG_LESS_THAN
	// if () { break eatApple; } 
	CMP r0 r0
	JMP .END_IF_4 FLAG_ZERO
	JMP .LOOP_END_eatApple
label END_IF_4

	JMP .LOOP_START_eatApple
label LOOP_END_eatApple
	
	// snake_body_x[tail_index] -> tail_x;
	LDI r2 &snake_body_x
	LDR r3 &tail_index
	ADD r2 r3
	LDX r0 r2
	STR r0 &tail_x
	// snake_body_y[tail_index] -> tail_y;
	LDI r2 &snake_body_y
	LDR r3 &tail_index
	ADD r2 r3
	LDX r0 r2
	STR r0 &tail_y

	// eraseSnakeTail();
	JSR .FUNCTION_eraseSnakeTail
	
	// appleEatenCooldown == 0
	LDR r0 &appleEatenCooldown
	LDI r1 #0
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_EQUAL
	// if () { tail_index + 1 -> tail_index; }
	CMP r0 r0
	JMP .END_IF_5 FLAG_ZERO
	LDR r0 &tail_index
	ADI r0 #1
	STR r0 &tail_index
label END_IF_5

	// appleEatenCooldown > 0
	LDR r0 &appleEatenCooldown
	LDI r1 #0
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_GREATER_THAN
	// if () { appleEatenCooldown - 1 -> appleEatenCooldown; }
	CMP r0 r0
	JMP .END_IF_6 FLAG_ZERO
	LDR r0 &appleEatenCooldown
	ADI r0 #65535
	STR r0 &appleEatenCooldown
label END_IF_6

	// drawApples();
	JSR .FUNCTION_drawApples

	// end loop main
	JMP .LOOP_START_main
label LOOP_END_main

label FUNCTION_moveSnakeHead
	LDR r0 &currentDirection
	LDR r1 &up
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_EQUAL
	CMP r0 r0
	JMP .END_IF_8 FLAG_ZERO
	LDR r0 &head_y
	ADI r0 #65535
	STR r0 &head_y
label END_IF_8
	LDR r0 &currentDirection
	LDR r1 &down
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_EQUAL
	CMP r0 r0
	JMP .END_IF_9 FLAG_ZERO
	LDR r0 &head_y
	ADI r0 #1
	STR r0 &head_y
label END_IF_9
	LDR r0 &currentDirection
	LDR r1 &left
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_EQUAL
	CMP r0 r0
	JMP .END_IF_10 FLAG_ZERO
	LDR r0 &head_x
	ADI r0 #65535
	STR r0 &head_x
label END_IF_10
	LDR r0 &currentDirection
	LDR r1 &right
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 FLAG_EQUAL
	CMP r0 r0
	JMP .END_IF_11 FLAG_ZERO
	LDR r0 &head_x
	ADI r0 #1
	STR r0 &head_x
label END_IF_11
	RTS



label FUNCTION_drawSnakeHead
	LDI r0 #3
	STR r0 &screen_color
	LDR r0 &head_x
	STR r0 &screen_x
	LDR r0 &head_y
	STR r0 &screen_y
	JSR .FUNCTION_std::drawToScreen
	RTS

label FUNCTION_eraseSnakeTail
	LDI r0 #0
	STR r0 &screen_color
	LDR r0 &tail_x
	STR r0 &screen_x
	LDR r0 &tail_y
	STR r0 &screen_y
	JSR .FUNCTION_std::drawToScreen
	RTS

label FUNCTION_drawApples
	LDI r0 #0
	STR r0 &index
label LOOP_START_drawApples
	LDI r0 #2
	STR r0 &screen_color
	// apples_x[index] -> screen_x;
	LDI r2 &apples_x
	LDR r3 &index
	ADD r2 r3
	LDX r0 r2
	STR r0 &screen_x
	// apples_y[index] -> screen_y;
	LDI r2 &apples_y
	LDR r3 &index
	ADD r2 r3
	LDX r0 r2
	STR r0 &screen_y
	// std::drawToScreen();
	JSR .FUNCTION_std::drawToScreen
	// index + 1 -> index;
	LDR r0 &index
	ADI r0 #1
	STR r0 &index
	// (index >= 16)
	LDR r0 &index
	LDI r1 #16
	CMP r0 r1
	LDI r0 #0
	LDI r0 #1 !FLAG_LESS_THAN
	// if () { break drawApples }
	CMP r0 r0
	JMP .END_IF_7 FLAG_ZERO
	JMP .LOOP_END_drawApples
label END_IF_7

	JMP .LOOP_START_drawApples
label LOOP_END_drawApples
	RTS



// std::rand();
label FUNCTION_std::rand
	LDR r0 &current_rng_state
	LDI r1 #15
	JSR .MULTIPLICATION_SUBROUTINE
	ADI r0 #19
	MOV r1 r0
	SHR r1
	SHR r1
	SHL r0
	SHL r0
	XOR r0 r1
	MOV r1 r0
	SHR r1
	SHR r1
	SHL r0
	SHL r0
	XOR r0 r1
	MOV r1 r0
	SHR r1
	SHR r1
	SHL r0
	SHL r0
	XOR r0 r1
	MOV r1 r0
	SHR r1
	SHR r1
	SHL r0
	SHL r0
	XOR r0 r1
	STR r0 &current_rng_state
	RTS

// std::getInput();
label FUNCTION_std::getInput
	KIN r0
	RTS

// std::drawToScreen();
label FUNCTION_std::drawToScreen
	LDR r0 &screen_color
	LDR r2 &screen_x
	LDR r3 &screen_y
	DRW
	RTS

// Multiplication Subroutine
label MULTIPLICATION_SUBROUTINE
	MOV r2 r0
	LDI r0 #0
	CMP r1 r2
	MOV r3 r1 FLAG_LESS_THAN
	MOV r1 r2 FLAG_LESS_THAN
	MOV r2 r3 FLAG_LESS_THAN
label MULTIPLICATION_LOOP
	CMP r2 r2
	RTS FLAG_ZERO
	ADD r0 r1
	ADI r2 #65535
	JMP .MULTIPLICATION_LOOP



var key
var currentDirection

var up
var down
var left
var right

var head_x
var head_y

var tail_x
var tail_y

var head_index
var tail_index

var snake_body_x[512]
var snake_body_y[512]

var appleEatenCooldown

var apples_x[16]
var apples_y[16]

var index

var screen_color
var screen_x
var screen_y
var current_rng_state

